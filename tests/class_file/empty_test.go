package classfile_test

import (
	"bytes"
	"testing"

	"github.com/Gustrb/jbm/src/core"
)

// Bytecode generated from: `jbm/tests/Empty.java` using the `java` command
// then using the hexdump to read the bytecode, and finally, using the script
// `scripts/format_hexdump.py` to format the bytecode in a more readable way.
var EmptyClassFile = []byte{
	0xCA, 0xFE, 0xBA, 0xBE, 0x00, 0x00, 0x00, 0x41,
	0x00, 0x0F, 0x0A, 0x00, 0x02, 0x00, 0x03, 0x07,
	0x00, 0x04, 0x0C, 0x00, 0x05, 0x00, 0x06, 0x01,
	0x00, 0x10, 0x6A, 0x61, 0x76, 0x61, 0x2F, 0x6C,
	0x61, 0x6E, 0x67, 0x2F, 0x4F, 0x62, 0x6A, 0x65,
	0x63, 0x74, 0x01, 0x00, 0x06, 0x3C, 0x69, 0x6E,
	0x69, 0x74, 0x3E, 0x01, 0x00, 0x03, 0x28, 0x29,
	0x56, 0x07, 0x00, 0x08, 0x01, 0x00, 0x05, 0x45,
	0x6D, 0x70, 0x74, 0x79, 0x01, 0x00, 0x04, 0x43,
	0x6F, 0x64, 0x65, 0x01, 0x00, 0x0F, 0x4C, 0x69,
	0x6E, 0x65, 0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72,
	0x54, 0x61, 0x62, 0x6C, 0x65, 0x01, 0x00, 0x04,
	0x6D, 0x61, 0x69, 0x6E, 0x01, 0x00, 0x16, 0x28,
	0x5B, 0x4C, 0x6A, 0x61, 0x76, 0x61, 0x2F, 0x6C,
	0x61, 0x6E, 0x67, 0x2F, 0x53, 0x74, 0x72, 0x69,
	0x6E, 0x67, 0x3B, 0x29, 0x56, 0x01, 0x00, 0x0A,
	0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69,
	0x6C, 0x65, 0x01, 0x00, 0x0A, 0x45, 0x6D, 0x70,
	0x74, 0x79, 0x2E, 0x6A, 0x61, 0x76, 0x61, 0x00,
	0x21, 0x00, 0x07, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00,
	0x1D, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x05, 0x2A, 0xB7, 0x00, 0x01, 0xB1, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x06,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09,
	0x00, 0x0B, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x09,
	0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x01, 0xB1, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x06, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00,
	0x0D, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0E, 0x00,
}

func TestShouldAllowAValidJavaProgram(t *testing.T) {
	cf, err := core.ClassFileFromReader(bytes.NewReader(EmptyClassFile))

	if err != nil {
		t.Fatalf("Error reading class file: %s", err)
	}

	if len(cf.ConstantPool) != 14 {
		t.Fatalf("Expected constant pool of size 1, got %d", len(cf.ConstantPool))
	}

	expected := [14]string{
		"ConstantPoolIndexableInfo{ ClassIndex: 2, NameAndTypeIndex: 3 }",
		"ClassInfo{ NameIndex: 4 }",
		"NameAndTypeInfo{ NameIndex: 5, DescriptorIndex: 6 }",
		"UTF8Info{ Bytes: java/lang/Object }",
		"UTF8Info{ Bytes: <init> }",
		"UTF8Info{ Bytes: ()V }",
		"ClassInfo{ NameIndex: 8 }",
		"UTF8Info{ Bytes: Empty }",
		"UTF8Info{ Bytes: Code }",
		"UTF8Info{ Bytes: LineNumberTable }",
		"UTF8Info{ Bytes: main }",
		"UTF8Info{ Bytes: ([Ljava/lang/String;)V }",
		"UTF8Info{ Bytes: SourceFile }",
		"UTF8Info{ Bytes: Empty.java }",
	}

	for i, e := range expected {
		if cf.ConstantPool[i].String() != e {
			t.Fatalf("Expected constant pool entry %d to be %s, got %s", i, e, cf.ConstantPool[i].String())
		}
	}

	if cf.AccessFlags != 33 {
		t.Fatalf("Expected access flags to be 33, got %d", cf.AccessFlags)
	}

	if cf.ThisClass != 7 {
		t.Fatalf("Expected this class to be 7, got %d", cf.ThisClass)
	}

	if cf.SuperClass != 2 {
		t.Fatalf("Expected super class to be 2, got %d", cf.SuperClass)
	}

	if len(cf.Interfaces) != 0 {
		t.Fatalf("Expected interfaces to be empty, got %d", len(cf.Interfaces))
	}
}
